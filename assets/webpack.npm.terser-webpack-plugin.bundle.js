"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkecomm_levity"] = self["webpackChunkecomm_levity"] || []).push([["npm.terser-webpack-plugin"],{

/***/ "./node_modules/terser-webpack-plugin/dist/cjs.js":
/*!********************************************************!*\
  !*** ./node_modules/terser-webpack-plugin/dist/cjs.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst plugin = __webpack_require__(/*! ./index */ \"./node_modules/terser-webpack-plugin/dist/index.js\");\n\nmodule.exports = plugin.default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyLXdlYnBhY2stcGx1Z2luL2Rpc3QvY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxtRUFBUzs7QUFFaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbS1sZXZpdHkvLi9ub2RlX21vZHVsZXMvdGVyc2VyLXdlYnBhY2stcGx1Z2luL2Rpc3QvY2pzLmpzP2E4Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHBsdWdpbiA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdWdpbi5kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/terser-webpack-plugin/dist/cjs.js\n");

/***/ }),

/***/ "./node_modules/terser-webpack-plugin/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/terser-webpack-plugin/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar path = _interopRequireWildcard(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar os = _interopRequireWildcard(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'os'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\n\nvar _sourceMap = __webpack_require__(/*! source-map */ \"./node_modules/source-map/source-map.js\");\n\nvar _schemaUtils = __webpack_require__(/*! schema-utils */ \"./node_modules/schema-utils/dist/index.js\");\n\nvar _serializeJavascript = _interopRequireDefault(__webpack_require__(/*! serialize-javascript */ \"./node_modules/serialize-javascript/index.js\"));\n\nvar terserPackageJson = _interopRequireWildcard(__webpack_require__(/*! terser/package.json */ \"./node_modules/terser/package.json\"));\n\nvar _pLimit = _interopRequireDefault(__webpack_require__(/*! p-limit */ \"./node_modules/p-limit/index.js\"));\n\nvar _jestWorker = __webpack_require__(/*! jest-worker */ \"./node_modules/jest-worker/build/index.js\");\n\nvar schema = _interopRequireWildcard(__webpack_require__(/*! ./options.json */ \"./node_modules/terser-webpack-plugin/dist/options.json\"));\n\nvar _minify = __webpack_require__(/*! ./minify */ \"./node_modules/terser-webpack-plugin/dist/minify.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n\n/** @typedef {import(\"webpack\").WebpackError} WebpackError */\n\n/** @typedef {import(\"webpack\").Asset} Asset */\n\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserMinifyOptions */\n\n/** @typedef {import(\"jest-worker\").Worker} JestWorker */\n\n/** @typedef {import(\"source-map\").RawSourceMap} RawSourceMap */\n\n/** @typedef {import(\"./minify.js\").InternalMinifyOptions} InternalMinifyOptions */\n\n/** @typedef {import(\"./minify.js\").InternalMinifyResult} InternalMinifyResult */\n\n/** @typedef {import(\"./minify.js\").CustomMinifyOptions} CustomMinifyOptions */\n\n/** @typedef {RegExp | string} Rule */\n\n/** @typedef {Rule[] | Rule} Rules */\n\n/** @typedef {JestWorker & { transform: (options: string) => InternalMinifyResult, minify: (options: InternalMinifyOptions) => InternalMinifyResult }} MinifyWorker */\n\n/**\n * @callback ExtractCommentsFunction\n * @param {any} astNode\n * @param {{ value: string, type: 'comment1' | 'comment2' | 'comment3' | 'comment4', pos: number, line: number, col: number }} comment\n * @returns {boolean}\n */\n\n/**\n * @typedef {boolean | string | RegExp | ExtractCommentsFunction} ExtractCommentsCondition\n */\n\n/**\n * @typedef {string | ((fileData: any) => string)} ExtractCommentsFilename\n */\n\n/**\n * @typedef {boolean | string | ((commentsFile: string) => string)} ExtractCommentsBanner\n */\n\n/**\n * @typedef {Object} ExtractCommentsObject\n * @property {ExtractCommentsCondition} condition\n * @property {ExtractCommentsFilename} filename\n * @property {ExtractCommentsBanner} banner\n */\n\n/**\n * @callback CustomMinifyFunction\n * @param {{ [file: string]: string }} fileAndCode\n * @param {RawSourceMap} [sourceMap]\n * @param {Object.<any, any>} minifyOptions\n */\n\n/**\n * @typedef {ExtractCommentsCondition | ExtractCommentsObject} ExtractCommentsOptions\n */\n\n/**\n * @typedef {Object} PluginWithTerserOptions\n * @property {Rules} [test]\n * @property {Rules} [include]\n * @property {Rules} [exclude]\n * @property {TerserMinifyOptions} [terserOptions]\n * @property {ExtractCommentsOptions} [extractComments]\n * @property {boolean} [parallel]\n * @property {CustomMinifyFunction} [minify]\n */\n\n/**\n * @typedef {Object} PluginWithCustomMinifyOptions\n * @property {Rules} [test]\n * @property {Rules} [include]\n * @property {Rules} [exclude]\n * @property {Object.<any, any>} [terserOptions]\n * @property {ExtractCommentsOptions} [extractComments]\n * @property {boolean} [parallel]\n * @property {CustomMinifyFunction} [minify]\n */\n\n/**\n * @typedef {PluginWithTerserOptions | PluginWithCustomMinifyOptions} TerserPluginOptions\n */\nclass TerserPlugin {\n  /**\n   * @param {TerserPluginOptions} options\n   */\n  constructor(options = {}) {\n    (0, _schemaUtils.validate)(\n    /** @type {Schema} */\n    schema, options, {\n      name: \"Terser Plugin\",\n      baseDataPath: \"options\"\n    });\n    const {\n      minify,\n      terserOptions = {},\n      test = /\\.[cm]?js(\\?.*)?$/i,\n      extractComments = true,\n      parallel = true,\n      include,\n      exclude\n    } = options;\n    this.options = {\n      test,\n      extractComments,\n      parallel,\n      include,\n      exclude,\n      minify,\n      terserOptions\n    };\n  }\n  /**\n   * @private\n   * @param {any} input\n   * @returns {boolean}\n   */\n\n\n  static isSourceMap(input) {\n    // All required options for `new SourceMapConsumer(...options)`\n    // https://github.com/mozilla/source-map#new-sourcemapconsumerrawsourcemap\n    return Boolean(input && input.version && input.sources && Array.isArray(input.sources) && typeof input.mappings === \"string\");\n  }\n  /**\n   * @private\n   * @param {Error & { line: number, col: number}} error\n   * @param {string} file\n   * @param {Compilation[\"requestShortener\"]} [requestShortener]\n   * @param {SourceMapConsumer} [sourceMap]\n   * @returns {Error}\n   */\n\n\n  static buildError(error, file, requestShortener, sourceMap) {\n    if (error.line) {\n      const original = sourceMap && sourceMap.originalPositionFor({\n        line: error.line,\n        column: error.col\n      });\n\n      if (original && original.source && requestShortener) {\n        return new Error(`${file} from Terser\\n${error.message} [${requestShortener.shorten(original.source)}:${original.line},${original.column}][${file}:${error.line},${error.col}]${error.stack ? `\\n${error.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : \"\"}`);\n      }\n\n      return new Error(`${file} from Terser\\n${error.message} [${file}:${error.line},${error.col}]${error.stack ? `\\n${error.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : \"\"}`);\n    }\n\n    if (error.stack) {\n      return new Error(`${file} from Terser\\n${error.stack}`);\n    }\n\n    return new Error(`${file} from Terser\\n${error.message}`);\n  }\n  /**\n   * @private\n   * @param {boolean} parallel\n   * @returns {number}\n   */\n\n\n  static getAvailableNumberOfCores(parallel) {\n    // In some cases cpus() returns undefined\n    // https://github.com/nodejs/node/issues/19022\n    const cpus = os.cpus() || {\n      length: 1\n    };\n    return parallel === true ? cpus.length - 1 : Math.min(Number(parallel) || 0, cpus.length - 1);\n  }\n  /**\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {Record<string, import(\"webpack\").sources.Source>} assets\n   * @param {{availableNumberOfCores: number}} optimizeOptions\n   * @returns {Promise<void>}\n   */\n\n\n  async optimize(compiler, compilation, assets, optimizeOptions) {\n    const cache = compilation.getCache(\"TerserWebpackPlugin\");\n    let numberOfAssetsForMinify = 0;\n    const assetsForMinify = await Promise.all(Object.keys(assets).filter(name => {\n      const {\n        info\n      } =\n      /** @type {Asset} */\n      compilation.getAsset(name);\n\n      if ( // Skip double minimize assets from child compilation\n      info.minimized || // Skip minimizing for extracted comments assets\n      info.extractedComments) {\n        return false;\n      }\n\n      if (!compiler.webpack.ModuleFilenameHelpers.matchObject.bind( // eslint-disable-next-line no-undefined\n      undefined, this.options)(name)) {\n        return false;\n      }\n\n      return true;\n    }).map(async name => {\n      const {\n        info,\n        source\n      } =\n      /** @type {Asset} */\n      compilation.getAsset(name);\n      const eTag = cache.getLazyHashedEtag(source);\n      const cacheItem = cache.getItemCache(name, eTag);\n      const output = await cacheItem.getPromise();\n\n      if (!output) {\n        numberOfAssetsForMinify += 1;\n      }\n\n      return {\n        name,\n        info,\n        inputSource: source,\n        output,\n        cacheItem\n      };\n    }));\n    /** @type {undefined | (() => MinifyWorker)} */\n\n    let getWorker;\n    /** @type {undefined | MinifyWorker} */\n\n    let initializedWorker;\n    /** @type {undefined | number} */\n\n    let numberOfWorkers;\n\n    if (optimizeOptions.availableNumberOfCores > 0) {\n      // Do not create unnecessary workers when the number of files is less than the available cores, it saves memory\n      numberOfWorkers = Math.min(numberOfAssetsForMinify, optimizeOptions.availableNumberOfCores); // eslint-disable-next-line consistent-return\n\n      getWorker = () => {\n        if (initializedWorker) {\n          return initializedWorker;\n        }\n\n        initializedWorker =\n        /** @type {MinifyWorker} */\n        new _jestWorker.Worker(/*require.resolve*/(/*! ./minify */ \"./node_modules/terser-webpack-plugin/dist/minify.js\"), {\n          numWorkers: numberOfWorkers,\n          enableWorkerThreads: true\n        }); // https://github.com/facebook/jest/issues/8872#issuecomment-524822081\n\n        const workerStdout = initializedWorker.getStdout();\n\n        if (workerStdout) {\n          workerStdout.on(\"data\", chunk => process.stdout.write(chunk));\n        }\n\n        const workerStderr = initializedWorker.getStderr();\n\n        if (workerStderr) {\n          workerStderr.on(\"data\", chunk => process.stderr.write(chunk));\n        }\n\n        return initializedWorker;\n      };\n    }\n\n    const limit = (0, _pLimit.default)(getWorker && numberOfAssetsForMinify > 0 ?\n    /** @type {number} */\n    numberOfWorkers : Infinity);\n    const {\n      SourceMapSource,\n      ConcatSource,\n      RawSource\n    } = compiler.webpack.sources;\n    /** @typedef {{ extractedCommentsSource : import(\"webpack\").sources.RawSource, commentsFilename: string }} ExtractedCommentsInfo */\n\n    /** @type {Map<string, ExtractedCommentsInfo>} */\n\n    const allExtractedComments = new Map();\n    const scheduledTasks = [];\n\n    for (const asset of assetsForMinify) {\n      scheduledTasks.push(limit(async () => {\n        const {\n          name,\n          inputSource,\n          info,\n          cacheItem\n        } = asset;\n        let {\n          output\n        } = asset;\n\n        if (!output) {\n          let input;\n          /** @type {RawSourceMap | undefined} */\n\n          let inputSourceMap;\n          const {\n            source: sourceFromInputSource,\n            map\n          } = inputSource.sourceAndMap();\n          input = sourceFromInputSource;\n\n          if (map) {\n            if (TerserPlugin.isSourceMap(map)) {\n              inputSourceMap =\n              /** @type {RawSourceMap} */\n              map;\n            } else {\n              inputSourceMap =\n              /** @type {RawSourceMap} */\n              map;\n              compilation.warnings.push(\n              /** @type {WebpackError} */\n              new Error(`${name} contains invalid source map`));\n            }\n          }\n\n          if (Buffer.isBuffer(input)) {\n            input = input.toString();\n          }\n          /** @type {InternalMinifyOptions} */\n\n\n          const options = {\n            name,\n            input,\n            inputSourceMap,\n            minify: this.options.minify,\n            minifyOptions: { ...this.options.terserOptions\n            },\n            extractComments: this.options.extractComments\n          };\n\n          if (typeof options.minifyOptions.module === \"undefined\") {\n            if (typeof info.javascriptModule !== \"undefined\") {\n              options.minifyOptions.module = info.javascriptModule;\n            } else if (/\\.mjs(\\?.*)?$/i.test(name)) {\n              options.minifyOptions.module = true;\n            } else if (/\\.cjs(\\?.*)?$/i.test(name)) {\n              options.minifyOptions.module = false;\n            }\n          }\n\n          try {\n            output = await (getWorker ? getWorker().transform((0, _serializeJavascript.default)(options)) : (0, _minify.minify)(options));\n          } catch (error) {\n            const hasSourceMap = inputSourceMap && TerserPlugin.isSourceMap(inputSourceMap);\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            TerserPlugin.buildError(error, name, // eslint-disable-next-line no-undefined\n            hasSourceMap ? compilation.requestShortener : undefined, hasSourceMap ? new _sourceMap.SourceMapConsumer(\n            /** @type {RawSourceMap} */\n            inputSourceMap) : // eslint-disable-next-line no-undefined\n            undefined));\n            return;\n          }\n\n          let shebang;\n\n          if (\n          /** @type {ExtractCommentsObject} */\n          this.options.extractComments.banner !== false && output.extractedComments && output.extractedComments.length > 0 && output.code.startsWith(\"#!\")) {\n            const firstNewlinePosition = output.code.indexOf(\"\\n\");\n            shebang = output.code.substring(0, firstNewlinePosition);\n            output.code = output.code.substring(firstNewlinePosition + 1);\n          }\n\n          if (output.map) {\n            output.source = new SourceMapSource(output.code, name, output.map, input,\n            /** @type {RawSourceMap} */\n            inputSourceMap, true);\n          } else {\n            output.source = new RawSource(output.code);\n          }\n\n          if (output.extractedComments && output.extractedComments.length > 0) {\n            const commentsFilename =\n            /** @type {ExtractCommentsObject} */\n            this.options.extractComments.filename || \"[file].LICENSE.txt[query]\";\n            let query = \"\";\n            let filename = name;\n            const querySplit = filename.indexOf(\"?\");\n\n            if (querySplit >= 0) {\n              query = filename.substr(querySplit);\n              filename = filename.substr(0, querySplit);\n            }\n\n            const lastSlashIndex = filename.lastIndexOf(\"/\");\n            const basename = lastSlashIndex === -1 ? filename : filename.substr(lastSlashIndex + 1);\n            const data = {\n              filename,\n              basename,\n              query\n            };\n            output.commentsFilename = compilation.getPath(commentsFilename, data);\n            let banner; // Add a banner to the original file\n\n            if (\n            /** @type {ExtractCommentsObject} */\n            this.options.extractComments.banner !== false) {\n              banner =\n              /** @type {ExtractCommentsObject} */\n              this.options.extractComments.banner || `For license information please see ${path.relative(path.dirname(name), output.commentsFilename).replace(/\\\\/g, \"/\")}`;\n\n              if (typeof banner === \"function\") {\n                banner = banner(output.commentsFilename);\n              }\n\n              if (banner) {\n                output.source = new ConcatSource(shebang ? `${shebang}\\n` : \"\", `/*! ${banner} */\\n`, output.source);\n              }\n            }\n\n            const extractedCommentsString = output.extractedComments.sort().join(\"\\n\\n\");\n            output.extractedCommentsSource = new RawSource(`${extractedCommentsString}\\n`);\n          }\n\n          await cacheItem.storePromise({\n            source: output.source,\n            commentsFilename: output.commentsFilename,\n            extractedCommentsSource: output.extractedCommentsSource\n          });\n        }\n        /** @type {Record<string, any>} */\n\n\n        const newInfo = {\n          minimized: true\n        };\n        const {\n          source,\n          extractedCommentsSource\n        } = output; // Write extracted comments to commentsFilename\n\n        if (extractedCommentsSource) {\n          const {\n            commentsFilename\n          } = output;\n          newInfo.related = {\n            license: commentsFilename\n          };\n          allExtractedComments.set(name, {\n            extractedCommentsSource,\n            commentsFilename\n          });\n        }\n\n        compilation.updateAsset(name, source, newInfo);\n      }));\n    }\n\n    await Promise.all(scheduledTasks);\n\n    if (initializedWorker) {\n      await initializedWorker.end();\n    }\n    /** @typedef {{ source: import(\"webpack\").sources.Source, commentsFilename: string, from: string }} ExtractedCommentsInfoWIthFrom */\n\n\n    await Array.from(allExtractedComments).sort().reduce(\n    /**\n     * @param {Promise<unknown>} previousPromise\n     * @param {[string, ExtractedCommentsInfo]} extractedComments\n     * @returns {Promise<ExtractedCommentsInfoWIthFrom>}\n     */\n    async (previousPromise, [from, value]) => {\n      const previous =\n      /** @type {ExtractedCommentsInfoWIthFrom | undefined} **/\n      await previousPromise;\n      const {\n        commentsFilename,\n        extractedCommentsSource\n      } = value;\n\n      if (previous && previous.commentsFilename === commentsFilename) {\n        const {\n          from: previousFrom,\n          source: prevSource\n        } = previous;\n        const mergedName = `${previousFrom}|${from}`;\n        const name = `${commentsFilename}|${mergedName}`;\n        const eTag = [prevSource, extractedCommentsSource].map(item => cache.getLazyHashedEtag(item)).reduce((previousValue, currentValue) => cache.mergeEtags(previousValue, currentValue));\n        let source = await cache.getPromise(name, eTag);\n\n        if (!source) {\n          source = new ConcatSource(Array.from(new Set([...\n          /** @type {string}*/\n          prevSource.source().split(\"\\n\\n\"), ...\n          /** @type {string}*/\n          extractedCommentsSource.source().split(\"\\n\\n\")])).join(\"\\n\\n\"));\n          await cache.storePromise(name, eTag, source);\n        }\n\n        compilation.updateAsset(commentsFilename, source);\n        return {\n          source,\n          commentsFilename,\n          from: mergedName\n        };\n      }\n\n      const existingAsset = compilation.getAsset(commentsFilename);\n\n      if (existingAsset) {\n        return {\n          source: existingAsset.source,\n          commentsFilename,\n          from: commentsFilename\n        };\n      }\n\n      compilation.emitAsset(commentsFilename, extractedCommentsSource, {\n        extractedComments: true\n      });\n      return {\n        source: extractedCommentsSource,\n        commentsFilename,\n        from\n      };\n    },\n    /** @type {Promise<unknown>} */\n    Promise.resolve());\n  }\n  /**\n   * @private\n   * @param {any} environment\n   * @returns {TerserECMA}\n   */\n\n\n  static getEcmaVersion(environment) {\n    // ES 6th\n    if (environment.arrowFunction || environment.const || environment.destructuring || environment.forOf || environment.module) {\n      return 2015;\n    } // ES 11th\n\n\n    if (environment.bigIntLiteral || environment.dynamicImport) {\n      return 2020;\n    }\n\n    return 5;\n  }\n  /**\n   * @param {Compiler} compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      output\n    } = compiler.options;\n\n    if (typeof this.options.terserOptions.ecma === \"undefined\") {\n      this.options.terserOptions.ecma = TerserPlugin.getEcmaVersion(output.environment || {});\n    }\n\n    const pluginName = this.constructor.name;\n    const availableNumberOfCores = TerserPlugin.getAvailableNumberOfCores(this.options.parallel);\n    compiler.hooks.compilation.tap(pluginName, compilation => {\n      const hooks = compiler.webpack.javascript.JavascriptModulesPlugin.getCompilationHooks(compilation);\n      const data = (0, _serializeJavascript.default)({\n        terser: terserPackageJson.version,\n        terserOptions: this.options.terserOptions\n      });\n      hooks.chunkHash.tap(pluginName, (chunk, hash) => {\n        hash.update(\"TerserPlugin\");\n        hash.update(data);\n      });\n      compilation.hooks.processAssets.tapPromise({\n        name: pluginName,\n        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE,\n        additionalAssets: true\n      }, assets => this.optimize(compiler, compilation, assets, {\n        availableNumberOfCores\n      }));\n      compilation.hooks.statsPrinter.tap(pluginName, stats => {\n        stats.hooks.print.for(\"asset.info.minimized\").tap(\"terser-webpack-plugin\", (minimized, {\n          green,\n          formatFlag\n        }) => minimized ?\n        /** @type {Function} */\n        green(\n        /** @type {Function} */\n        formatFlag(\"minimized\")) : \"\");\n      });\n    });\n  }\n\n}\n\nvar _default = TerserPlugin;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyLXdlYnBhY2stcGx1Z2luL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZUFBZTs7QUFFZixtQ0FBbUMsbUJBQU8sQ0FBQyxtSUFBTTs7QUFFakQsaUNBQWlDLG1CQUFPLENBQUMsaUlBQUk7O0FBRTdDLGlCQUFpQixtQkFBTyxDQUFDLDJEQUFZOztBQUVyQyxtQkFBbUIsbUJBQU8sQ0FBQywrREFBYzs7QUFFekMsa0RBQWtELG1CQUFPLENBQUMsMEVBQXNCOztBQUVoRixnREFBZ0QsbUJBQU8sQ0FBQywrREFBcUI7O0FBRTdFLHFDQUFxQyxtQkFBTyxDQUFDLGdEQUFTOztBQUV0RCxrQkFBa0IsbUJBQU8sQ0FBQyw4REFBYTs7QUFFdkMscUNBQXFDLG1CQUFPLENBQUMsOEVBQWdCOztBQUU3RCxjQUFjLG1CQUFPLENBQUMscUVBQVU7O0FBRWhDLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLGlEQUFpRCxnREFBZ0QsdUNBQXVDLHNDQUFzQyw0REFBNEQsNERBQTREOztBQUV0UyxxREFBcUQsNkNBQTZDLGNBQWMsNEVBQTRFLFNBQVMsa0JBQWtCLG1EQUFtRCwrQkFBK0IseUJBQXlCLGlCQUFpQixzRkFBc0YsdUJBQXVCLDJFQUEyRSxxRkFBcUYsc0NBQXNDLDRDQUE0QyxPQUFPLDhCQUE4QixzQkFBc0IsYUFBYSwwQkFBMEI7O0FBRXB4QixjQUFjLHFEQUFxRDs7QUFFbkUsY0FBYyw0QkFBNEI7O0FBRTFDLGNBQWMsK0JBQStCOztBQUU3QyxjQUFjLGdDQUFnQzs7QUFFOUMsY0FBYyx5QkFBeUI7O0FBRXZDLGNBQWMsdUJBQXVCOztBQUVyQyxjQUFjLGdDQUFnQzs7QUFFOUMsY0FBYyw4QkFBOEI7O0FBRTVDLGNBQWMsbUNBQW1DOztBQUVqRCxjQUFjLDZDQUE2Qzs7QUFFM0QsY0FBYyw0Q0FBNEM7O0FBRTFELGNBQWMsMkNBQTJDOztBQUV6RCxj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QixPQUFPO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsNEZBQTRGO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbS1sZXZpdHkvLi9ub2RlX21vZHVsZXMvdGVyc2VyLXdlYnBhY2stcGx1Z2luL2Rpc3QvaW5kZXguanM/OWYzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIHBhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbnZhciBvcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJvc1wiKSk7XG5cbnZhciBfc291cmNlTWFwID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIik7XG5cbnZhciBfc2NoZW1hVXRpbHMgPSByZXF1aXJlKFwic2NoZW1hLXV0aWxzXCIpO1xuXG52YXIgX3NlcmlhbGl6ZUphdmFzY3JpcHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJzZXJpYWxpemUtamF2YXNjcmlwdFwiKSk7XG5cbnZhciB0ZXJzZXJQYWNrYWdlSnNvbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJ0ZXJzZXIvcGFja2FnZS5qc29uXCIpKTtcblxudmFyIF9wTGltaXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwLWxpbWl0XCIpKTtcblxudmFyIF9qZXN0V29ya2VyID0gcmVxdWlyZShcImplc3Qtd29ya2VyXCIpO1xuXG52YXIgc2NoZW1hID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vb3B0aW9ucy5qc29uXCIpKTtcblxudmFyIF9taW5pZnkgPSByZXF1aXJlKFwiLi9taW5pZnlcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwic2NoZW1hLXV0aWxzL2RlY2xhcmF0aW9ucy92YWxpZGF0ZVwiKS5TY2hlbWF9IFNjaGVtYSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIndlYnBhY2tcIikuQ29tcGlsZXJ9IENvbXBpbGVyICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwid2VicGFja1wiKS5Db21waWxhdGlvbn0gQ29tcGlsYXRpb24gKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCJ3ZWJwYWNrXCIpLldlYnBhY2tFcnJvcn0gV2VicGFja0Vycm9yICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwid2VicGFja1wiKS5Bc3NldH0gQXNzZXQgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCJ0ZXJzZXJcIikuRUNNQX0gVGVyc2VyRUNNQSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcInRlcnNlclwiKS5NaW5pZnlPcHRpb25zfSBUZXJzZXJNaW5pZnlPcHRpb25zICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiamVzdC13b3JrZXJcIikuV29ya2VyfSBKZXN0V29ya2VyICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwic291cmNlLW1hcFwiKS5SYXdTb3VyY2VNYXB9IFJhd1NvdXJjZU1hcCAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4vbWluaWZ5LmpzXCIpLkludGVybmFsTWluaWZ5T3B0aW9uc30gSW50ZXJuYWxNaW5pZnlPcHRpb25zICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9taW5pZnkuanNcIikuSW50ZXJuYWxNaW5pZnlSZXN1bHR9IEludGVybmFsTWluaWZ5UmVzdWx0ICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9taW5pZnkuanNcIikuQ3VzdG9tTWluaWZ5T3B0aW9uc30gQ3VzdG9tTWluaWZ5T3B0aW9ucyAqL1xuXG4vKiogQHR5cGVkZWYge1JlZ0V4cCB8IHN0cmluZ30gUnVsZSAqL1xuXG4vKiogQHR5cGVkZWYge1J1bGVbXSB8IFJ1bGV9IFJ1bGVzICovXG5cbi8qKiBAdHlwZWRlZiB7SmVzdFdvcmtlciAmIHsgdHJhbnNmb3JtOiAob3B0aW9uczogc3RyaW5nKSA9PiBJbnRlcm5hbE1pbmlmeVJlc3VsdCwgbWluaWZ5OiAob3B0aW9uczogSW50ZXJuYWxNaW5pZnlPcHRpb25zKSA9PiBJbnRlcm5hbE1pbmlmeVJlc3VsdCB9fSBNaW5pZnlXb3JrZXIgKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRXh0cmFjdENvbW1lbnRzRnVuY3Rpb25cbiAqIEBwYXJhbSB7YW55fSBhc3ROb2RlXG4gKiBAcGFyYW0ge3sgdmFsdWU6IHN0cmluZywgdHlwZTogJ2NvbW1lbnQxJyB8ICdjb21tZW50MicgfCAnY29tbWVudDMnIHwgJ2NvbW1lbnQ0JywgcG9zOiBudW1iZXIsIGxpbmU6IG51bWJlciwgY29sOiBudW1iZXIgfX0gY29tbWVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Ym9vbGVhbiB8IHN0cmluZyB8IFJlZ0V4cCB8IEV4dHJhY3RDb21tZW50c0Z1bmN0aW9ufSBFeHRyYWN0Q29tbWVudHNDb25kaXRpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmcgfCAoKGZpbGVEYXRhOiBhbnkpID0+IHN0cmluZyl9IEV4dHJhY3RDb21tZW50c0ZpbGVuYW1lXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Ym9vbGVhbiB8IHN0cmluZyB8ICgoY29tbWVudHNGaWxlOiBzdHJpbmcpID0+IHN0cmluZyl9IEV4dHJhY3RDb21tZW50c0Jhbm5lclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRXh0cmFjdENvbW1lbnRzT2JqZWN0XG4gKiBAcHJvcGVydHkge0V4dHJhY3RDb21tZW50c0NvbmRpdGlvbn0gY29uZGl0aW9uXG4gKiBAcHJvcGVydHkge0V4dHJhY3RDb21tZW50c0ZpbGVuYW1lfSBmaWxlbmFtZVxuICogQHByb3BlcnR5IHtFeHRyYWN0Q29tbWVudHNCYW5uZXJ9IGJhbm5lclxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEN1c3RvbU1pbmlmeUZ1bmN0aW9uXG4gKiBAcGFyYW0ge3sgW2ZpbGU6IHN0cmluZ106IHN0cmluZyB9fSBmaWxlQW5kQ29kZVxuICogQHBhcmFtIHtSYXdTb3VyY2VNYXB9IFtzb3VyY2VNYXBdXG4gKiBAcGFyYW0ge09iamVjdC48YW55LCBhbnk+fSBtaW5pZnlPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RXh0cmFjdENvbW1lbnRzQ29uZGl0aW9uIHwgRXh0cmFjdENvbW1lbnRzT2JqZWN0fSBFeHRyYWN0Q29tbWVudHNPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQbHVnaW5XaXRoVGVyc2VyT3B0aW9uc1xuICogQHByb3BlcnR5IHtSdWxlc30gW3Rlc3RdXG4gKiBAcHJvcGVydHkge1J1bGVzfSBbaW5jbHVkZV1cbiAqIEBwcm9wZXJ0eSB7UnVsZXN9IFtleGNsdWRlXVxuICogQHByb3BlcnR5IHtUZXJzZXJNaW5pZnlPcHRpb25zfSBbdGVyc2VyT3B0aW9uc11cbiAqIEBwcm9wZXJ0eSB7RXh0cmFjdENvbW1lbnRzT3B0aW9uc30gW2V4dHJhY3RDb21tZW50c11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BhcmFsbGVsXVxuICogQHByb3BlcnR5IHtDdXN0b21NaW5pZnlGdW5jdGlvbn0gW21pbmlmeV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBsdWdpbldpdGhDdXN0b21NaW5pZnlPcHRpb25zXG4gKiBAcHJvcGVydHkge1J1bGVzfSBbdGVzdF1cbiAqIEBwcm9wZXJ0eSB7UnVsZXN9IFtpbmNsdWRlXVxuICogQHByb3BlcnR5IHtSdWxlc30gW2V4Y2x1ZGVdXG4gKiBAcHJvcGVydHkge09iamVjdC48YW55LCBhbnk+fSBbdGVyc2VyT3B0aW9uc11cbiAqIEBwcm9wZXJ0eSB7RXh0cmFjdENvbW1lbnRzT3B0aW9uc30gW2V4dHJhY3RDb21tZW50c11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BhcmFsbGVsXVxuICogQHByb3BlcnR5IHtDdXN0b21NaW5pZnlGdW5jdGlvbn0gW21pbmlmeV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtQbHVnaW5XaXRoVGVyc2VyT3B0aW9ucyB8IFBsdWdpbldpdGhDdXN0b21NaW5pZnlPcHRpb25zfSBUZXJzZXJQbHVnaW5PcHRpb25zXG4gKi9cbmNsYXNzIFRlcnNlclBsdWdpbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RlcnNlclBsdWdpbk9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICgwLCBfc2NoZW1hVXRpbHMudmFsaWRhdGUpKFxuICAgIC8qKiBAdHlwZSB7U2NoZW1hfSAqL1xuICAgIHNjaGVtYSwgb3B0aW9ucywge1xuICAgICAgbmFtZTogXCJUZXJzZXIgUGx1Z2luXCIsXG4gICAgICBiYXNlRGF0YVBhdGg6IFwib3B0aW9uc1wiXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgbWluaWZ5LFxuICAgICAgdGVyc2VyT3B0aW9ucyA9IHt9LFxuICAgICAgdGVzdCA9IC9cXC5bY21dP2pzKFxcPy4qKT8kL2ksXG4gICAgICBleHRyYWN0Q29tbWVudHMgPSB0cnVlLFxuICAgICAgcGFyYWxsZWwgPSB0cnVlLFxuICAgICAgaW5jbHVkZSxcbiAgICAgIGV4Y2x1ZGVcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICB0ZXN0LFxuICAgICAgZXh0cmFjdENvbW1lbnRzLFxuICAgICAgcGFyYWxsZWwsXG4gICAgICBpbmNsdWRlLFxuICAgICAgZXhjbHVkZSxcbiAgICAgIG1pbmlmeSxcbiAgICAgIHRlcnNlck9wdGlvbnNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2FueX0gaW5wdXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgc3RhdGljIGlzU291cmNlTWFwKGlucHV0KSB7XG4gICAgLy8gQWxsIHJlcXVpcmVkIG9wdGlvbnMgZm9yIGBuZXcgU291cmNlTWFwQ29uc3VtZXIoLi4ub3B0aW9ucylgXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcCNuZXctc291cmNlbWFwY29uc3VtZXJyYXdzb3VyY2VtYXBcbiAgICByZXR1cm4gQm9vbGVhbihpbnB1dCAmJiBpbnB1dC52ZXJzaW9uICYmIGlucHV0LnNvdXJjZXMgJiYgQXJyYXkuaXNBcnJheShpbnB1dC5zb3VyY2VzKSAmJiB0eXBlb2YgaW5wdXQubWFwcGluZ3MgPT09IFwic3RyaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Vycm9yICYgeyBsaW5lOiBudW1iZXIsIGNvbDogbnVtYmVyfX0gZXJyb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVcbiAgICogQHBhcmFtIHtDb21waWxhdGlvbltcInJlcXVlc3RTaG9ydGVuZXJcIl19IFtyZXF1ZXN0U2hvcnRlbmVyXVxuICAgKiBAcGFyYW0ge1NvdXJjZU1hcENvbnN1bWVyfSBbc291cmNlTWFwXVxuICAgKiBAcmV0dXJucyB7RXJyb3J9XG4gICAqL1xuXG5cbiAgc3RhdGljIGJ1aWxkRXJyb3IoZXJyb3IsIGZpbGUsIHJlcXVlc3RTaG9ydGVuZXIsIHNvdXJjZU1hcCkge1xuICAgIGlmIChlcnJvci5saW5lKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IHNvdXJjZU1hcCAmJiBzb3VyY2VNYXAub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgIGxpbmU6IGVycm9yLmxpbmUsXG4gICAgICAgIGNvbHVtbjogZXJyb3IuY29sXG4gICAgICB9KTtcblxuICAgICAgaWYgKG9yaWdpbmFsICYmIG9yaWdpbmFsLnNvdXJjZSAmJiByZXF1ZXN0U2hvcnRlbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYCR7ZmlsZX0gZnJvbSBUZXJzZXJcXG4ke2Vycm9yLm1lc3NhZ2V9IFske3JlcXVlc3RTaG9ydGVuZXIuc2hvcnRlbihvcmlnaW5hbC5zb3VyY2UpfToke29yaWdpbmFsLmxpbmV9LCR7b3JpZ2luYWwuY29sdW1ufV1bJHtmaWxlfToke2Vycm9yLmxpbmV9LCR7ZXJyb3IuY29sfV0ke2Vycm9yLnN0YWNrID8gYFxcbiR7ZXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSkuam9pbihcIlxcblwiKX1gIDogXCJcIn1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBFcnJvcihgJHtmaWxlfSBmcm9tIFRlcnNlclxcbiR7ZXJyb3IubWVzc2FnZX0gWyR7ZmlsZX06JHtlcnJvci5saW5lfSwke2Vycm9yLmNvbH1dJHtlcnJvci5zdGFjayA/IGBcXG4ke2Vycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpLmpvaW4oXCJcXG5cIil9YCA6IFwiXCJ9YCk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGAke2ZpbGV9IGZyb20gVGVyc2VyXFxuJHtlcnJvci5zdGFja31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVycm9yKGAke2ZpbGV9IGZyb20gVGVyc2VyXFxuJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFsbGVsXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgc3RhdGljIGdldEF2YWlsYWJsZU51bWJlck9mQ29yZXMocGFyYWxsZWwpIHtcbiAgICAvLyBJbiBzb21lIGNhc2VzIGNwdXMoKSByZXR1cm5zIHVuZGVmaW5lZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMTkwMjJcbiAgICBjb25zdCBjcHVzID0gb3MuY3B1cygpIHx8IHtcbiAgICAgIGxlbmd0aDogMVxuICAgIH07XG4gICAgcmV0dXJuIHBhcmFsbGVsID09PSB0cnVlID8gY3B1cy5sZW5ndGggLSAxIDogTWF0aC5taW4oTnVtYmVyKHBhcmFsbGVsKSB8fCAwLCBjcHVzLmxlbmd0aCAtIDEpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbXBpbGVyfSBjb21waWxlclxuICAgKiBAcGFyYW0ge0NvbXBpbGF0aW9ufSBjb21waWxhdGlvblxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGltcG9ydChcIndlYnBhY2tcIikuc291cmNlcy5Tb3VyY2U+fSBhc3NldHNcbiAgICogQHBhcmFtIHt7YXZhaWxhYmxlTnVtYmVyT2ZDb3JlczogbnVtYmVyfX0gb3B0aW1pemVPcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cblxuXG4gIGFzeW5jIG9wdGltaXplKGNvbXBpbGVyLCBjb21waWxhdGlvbiwgYXNzZXRzLCBvcHRpbWl6ZU9wdGlvbnMpIHtcbiAgICBjb25zdCBjYWNoZSA9IGNvbXBpbGF0aW9uLmdldENhY2hlKFwiVGVyc2VyV2VicGFja1BsdWdpblwiKTtcbiAgICBsZXQgbnVtYmVyT2ZBc3NldHNGb3JNaW5pZnkgPSAwO1xuICAgIGNvbnN0IGFzc2V0c0Zvck1pbmlmeSA9IGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKGFzc2V0cykuZmlsdGVyKG5hbWUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbmZvXG4gICAgICB9ID1cbiAgICAgIC8qKiBAdHlwZSB7QXNzZXR9ICovXG4gICAgICBjb21waWxhdGlvbi5nZXRBc3NldChuYW1lKTtcblxuICAgICAgaWYgKCAvLyBTa2lwIGRvdWJsZSBtaW5pbWl6ZSBhc3NldHMgZnJvbSBjaGlsZCBjb21waWxhdGlvblxuICAgICAgaW5mby5taW5pbWl6ZWQgfHwgLy8gU2tpcCBtaW5pbWl6aW5nIGZvciBleHRyYWN0ZWQgY29tbWVudHMgYXNzZXRzXG4gICAgICBpbmZvLmV4dHJhY3RlZENvbW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb21waWxlci53ZWJwYWNrLk1vZHVsZUZpbGVuYW1lSGVscGVycy5tYXRjaE9iamVjdC5iaW5kKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICB1bmRlZmluZWQsIHRoaXMub3B0aW9ucykobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KS5tYXAoYXN5bmMgbmFtZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGluZm8sXG4gICAgICAgIHNvdXJjZVxuICAgICAgfSA9XG4gICAgICAvKiogQHR5cGUge0Fzc2V0fSAqL1xuICAgICAgY29tcGlsYXRpb24uZ2V0QXNzZXQobmFtZSk7XG4gICAgICBjb25zdCBlVGFnID0gY2FjaGUuZ2V0TGF6eUhhc2hlZEV0YWcoc291cmNlKTtcbiAgICAgIGNvbnN0IGNhY2hlSXRlbSA9IGNhY2hlLmdldEl0ZW1DYWNoZShuYW1lLCBlVGFnKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGNhY2hlSXRlbS5nZXRQcm9taXNlKCk7XG5cbiAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgIG51bWJlck9mQXNzZXRzRm9yTWluaWZ5ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGluZm8sXG4gICAgICAgIGlucHV0U291cmNlOiBzb3VyY2UsXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgY2FjaGVJdGVtXG4gICAgICB9O1xuICAgIH0pKTtcbiAgICAvKiogQHR5cGUge3VuZGVmaW5lZCB8ICgoKSA9PiBNaW5pZnlXb3JrZXIpfSAqL1xuXG4gICAgbGV0IGdldFdvcmtlcjtcbiAgICAvKiogQHR5cGUge3VuZGVmaW5lZCB8IE1pbmlmeVdvcmtlcn0gKi9cblxuICAgIGxldCBpbml0aWFsaXplZFdvcmtlcjtcbiAgICAvKiogQHR5cGUge3VuZGVmaW5lZCB8IG51bWJlcn0gKi9cblxuICAgIGxldCBudW1iZXJPZldvcmtlcnM7XG5cbiAgICBpZiAob3B0aW1pemVPcHRpb25zLmF2YWlsYWJsZU51bWJlck9mQ29yZXMgPiAwKSB7XG4gICAgICAvLyBEbyBub3QgY3JlYXRlIHVubmVjZXNzYXJ5IHdvcmtlcnMgd2hlbiB0aGUgbnVtYmVyIG9mIGZpbGVzIGlzIGxlc3MgdGhhbiB0aGUgYXZhaWxhYmxlIGNvcmVzLCBpdCBzYXZlcyBtZW1vcnlcbiAgICAgIG51bWJlck9mV29ya2VycyA9IE1hdGgubWluKG51bWJlck9mQXNzZXRzRm9yTWluaWZ5LCBvcHRpbWl6ZU9wdGlvbnMuYXZhaWxhYmxlTnVtYmVyT2ZDb3Jlcyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXG4gICAgICBnZXRXb3JrZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpbml0aWFsaXplZFdvcmtlcikge1xuICAgICAgICAgIHJldHVybiBpbml0aWFsaXplZFdvcmtlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxpemVkV29ya2VyID1cbiAgICAgICAgLyoqIEB0eXBlIHtNaW5pZnlXb3JrZXJ9ICovXG4gICAgICAgIG5ldyBfamVzdFdvcmtlci5Xb3JrZXIocmVxdWlyZS5yZXNvbHZlKFwiLi9taW5pZnlcIiksIHtcbiAgICAgICAgICBudW1Xb3JrZXJzOiBudW1iZXJPZldvcmtlcnMsXG4gICAgICAgICAgZW5hYmxlV29ya2VyVGhyZWFkczogdHJ1ZVxuICAgICAgICB9KTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvaXNzdWVzLzg4NzIjaXNzdWVjb21tZW50LTUyNDgyMjA4MVxuXG4gICAgICAgIGNvbnN0IHdvcmtlclN0ZG91dCA9IGluaXRpYWxpemVkV29ya2VyLmdldFN0ZG91dCgpO1xuXG4gICAgICAgIGlmICh3b3JrZXJTdGRvdXQpIHtcbiAgICAgICAgICB3b3JrZXJTdGRvdXQub24oXCJkYXRhXCIsIGNodW5rID0+IHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNodW5rKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3b3JrZXJTdGRlcnIgPSBpbml0aWFsaXplZFdvcmtlci5nZXRTdGRlcnIoKTtcblxuICAgICAgICBpZiAod29ya2VyU3RkZXJyKSB7XG4gICAgICAgICAgd29ya2VyU3RkZXJyLm9uKFwiZGF0YVwiLCBjaHVuayA9PiBwcm9jZXNzLnN0ZGVyci53cml0ZShjaHVuaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVkV29ya2VyO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW1pdCA9ICgwLCBfcExpbWl0LmRlZmF1bHQpKGdldFdvcmtlciAmJiBudW1iZXJPZkFzc2V0c0Zvck1pbmlmeSA+IDAgP1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIG51bWJlck9mV29ya2VycyA6IEluZmluaXR5KTtcbiAgICBjb25zdCB7XG4gICAgICBTb3VyY2VNYXBTb3VyY2UsXG4gICAgICBDb25jYXRTb3VyY2UsXG4gICAgICBSYXdTb3VyY2VcbiAgICB9ID0gY29tcGlsZXIud2VicGFjay5zb3VyY2VzO1xuICAgIC8qKiBAdHlwZWRlZiB7eyBleHRyYWN0ZWRDb21tZW50c1NvdXJjZSA6IGltcG9ydChcIndlYnBhY2tcIikuc291cmNlcy5SYXdTb3VyY2UsIGNvbW1lbnRzRmlsZW5hbWU6IHN0cmluZyB9fSBFeHRyYWN0ZWRDb21tZW50c0luZm8gKi9cblxuICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgRXh0cmFjdGVkQ29tbWVudHNJbmZvPn0gKi9cblxuICAgIGNvbnN0IGFsbEV4dHJhY3RlZENvbW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHNjaGVkdWxlZFRhc2tzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGFzc2V0IG9mIGFzc2V0c0Zvck1pbmlmeSkge1xuICAgICAgc2NoZWR1bGVkVGFza3MucHVzaChsaW1pdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGlucHV0U291cmNlLFxuICAgICAgICAgIGluZm8sXG4gICAgICAgICAgY2FjaGVJdGVtXG4gICAgICAgIH0gPSBhc3NldDtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBvdXRwdXRcbiAgICAgICAgfSA9IGFzc2V0O1xuXG4gICAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgICAgbGV0IGlucHV0O1xuICAgICAgICAgIC8qKiBAdHlwZSB7UmF3U291cmNlTWFwIHwgdW5kZWZpbmVkfSAqL1xuXG4gICAgICAgICAgbGV0IGlucHV0U291cmNlTWFwO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlRnJvbUlucHV0U291cmNlLFxuICAgICAgICAgICAgbWFwXG4gICAgICAgICAgfSA9IGlucHV0U291cmNlLnNvdXJjZUFuZE1hcCgpO1xuICAgICAgICAgIGlucHV0ID0gc291cmNlRnJvbUlucHV0U291cmNlO1xuXG4gICAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgaWYgKFRlcnNlclBsdWdpbi5pc1NvdXJjZU1hcChtYXApKSB7XG4gICAgICAgICAgICAgIGlucHV0U291cmNlTWFwID1cbiAgICAgICAgICAgICAgLyoqIEB0eXBlIHtSYXdTb3VyY2VNYXB9ICovXG4gICAgICAgICAgICAgIG1hcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0U291cmNlTWFwID1cbiAgICAgICAgICAgICAgLyoqIEB0eXBlIHtSYXdTb3VyY2VNYXB9ICovXG4gICAgICAgICAgICAgIG1hcDtcbiAgICAgICAgICAgICAgY29tcGlsYXRpb24ud2FybmluZ3MucHVzaChcbiAgICAgICAgICAgICAgLyoqIEB0eXBlIHtXZWJwYWNrRXJyb3J9ICovXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihgJHtuYW1lfSBjb250YWlucyBpbnZhbGlkIHNvdXJjZSBtYXBgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEB0eXBlIHtJbnRlcm5hbE1pbmlmeU9wdGlvbnN9ICovXG5cblxuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnB1dFNvdXJjZU1hcCxcbiAgICAgICAgICAgIG1pbmlmeTogdGhpcy5vcHRpb25zLm1pbmlmeSxcbiAgICAgICAgICAgIG1pbmlmeU9wdGlvbnM6IHsgLi4udGhpcy5vcHRpb25zLnRlcnNlck9wdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRyYWN0Q29tbWVudHM6IHRoaXMub3B0aW9ucy5leHRyYWN0Q29tbWVudHNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1pbmlmeU9wdGlvbnMubW9kdWxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm8uamF2YXNjcmlwdE1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICBvcHRpb25zLm1pbmlmeU9wdGlvbnMubW9kdWxlID0gaW5mby5qYXZhc2NyaXB0TW9kdWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXFwubWpzKFxcPy4qKT8kL2kudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICBvcHRpb25zLm1pbmlmeU9wdGlvbnMubW9kdWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcLmNqcyhcXD8uKik/JC9pLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5taW5pZnlPcHRpb25zLm1vZHVsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBhd2FpdCAoZ2V0V29ya2VyID8gZ2V0V29ya2VyKCkudHJhbnNmb3JtKCgwLCBfc2VyaWFsaXplSmF2YXNjcmlwdC5kZWZhdWx0KShvcHRpb25zKSkgOiAoMCwgX21pbmlmeS5taW5pZnkpKG9wdGlvbnMpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgaGFzU291cmNlTWFwID0gaW5wdXRTb3VyY2VNYXAgJiYgVGVyc2VyUGx1Z2luLmlzU291cmNlTWFwKGlucHV0U291cmNlTWFwKTtcbiAgICAgICAgICAgIGNvbXBpbGF0aW9uLmVycm9ycy5wdXNoKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtXZWJwYWNrRXJyb3J9ICovXG4gICAgICAgICAgICBUZXJzZXJQbHVnaW4uYnVpbGRFcnJvcihlcnJvciwgbmFtZSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgICAgICAgICAgaGFzU291cmNlTWFwID8gY29tcGlsYXRpb24ucmVxdWVzdFNob3J0ZW5lciA6IHVuZGVmaW5lZCwgaGFzU291cmNlTWFwID8gbmV3IF9zb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIoXG4gICAgICAgICAgICAvKiogQHR5cGUge1Jhd1NvdXJjZU1hcH0gKi9cbiAgICAgICAgICAgIGlucHV0U291cmNlTWFwKSA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICAgICAgICAgIHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBzaGViYW5nO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIC8qKiBAdHlwZSB7RXh0cmFjdENvbW1lbnRzT2JqZWN0fSAqL1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRyYWN0Q29tbWVudHMuYmFubmVyICE9PSBmYWxzZSAmJiBvdXRwdXQuZXh0cmFjdGVkQ29tbWVudHMgJiYgb3V0cHV0LmV4dHJhY3RlZENvbW1lbnRzLmxlbmd0aCA+IDAgJiYgb3V0cHV0LmNvZGUuc3RhcnRzV2l0aChcIiMhXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdE5ld2xpbmVQb3NpdGlvbiA9IG91dHB1dC5jb2RlLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICBzaGViYW5nID0gb3V0cHV0LmNvZGUuc3Vic3RyaW5nKDAsIGZpcnN0TmV3bGluZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIG91dHB1dC5jb2RlID0gb3V0cHV0LmNvZGUuc3Vic3RyaW5nKGZpcnN0TmV3bGluZVBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG91dHB1dC5tYXApIHtcbiAgICAgICAgICAgIG91dHB1dC5zb3VyY2UgPSBuZXcgU291cmNlTWFwU291cmNlKG91dHB1dC5jb2RlLCBuYW1lLCBvdXRwdXQubWFwLCBpbnB1dCxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UmF3U291cmNlTWFwfSAqL1xuICAgICAgICAgICAgaW5wdXRTb3VyY2VNYXAsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQuc291cmNlID0gbmV3IFJhd1NvdXJjZShvdXRwdXQuY29kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG91dHB1dC5leHRyYWN0ZWRDb21tZW50cyAmJiBvdXRwdXQuZXh0cmFjdGVkQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudHNGaWxlbmFtZSA9XG4gICAgICAgICAgICAvKiogQHR5cGUge0V4dHJhY3RDb21tZW50c09iamVjdH0gKi9cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRyYWN0Q29tbWVudHMuZmlsZW5hbWUgfHwgXCJbZmlsZV0uTElDRU5TRS50eHRbcXVlcnldXCI7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGZpbGVuYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5U3BsaXQgPSBmaWxlbmFtZS5pbmRleE9mKFwiP1wiKTtcblxuICAgICAgICAgICAgaWYgKHF1ZXJ5U3BsaXQgPj0gMCkge1xuICAgICAgICAgICAgICBxdWVyeSA9IGZpbGVuYW1lLnN1YnN0cihxdWVyeVNwbGl0KTtcbiAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5zdWJzdHIoMCwgcXVlcnlTcGxpdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxhc3RTbGFzaEluZGV4ID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgY29uc3QgYmFzZW5hbWUgPSBsYXN0U2xhc2hJbmRleCA9PT0gLTEgPyBmaWxlbmFtZSA6IGZpbGVuYW1lLnN1YnN0cihsYXN0U2xhc2hJbmRleCArIDEpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG91dHB1dC5jb21tZW50c0ZpbGVuYW1lID0gY29tcGlsYXRpb24uZ2V0UGF0aChjb21tZW50c0ZpbGVuYW1lLCBkYXRhKTtcbiAgICAgICAgICAgIGxldCBiYW5uZXI7IC8vIEFkZCBhIGJhbm5lciB0byB0aGUgb3JpZ2luYWwgZmlsZVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvKiogQHR5cGUge0V4dHJhY3RDb21tZW50c09iamVjdH0gKi9cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRyYWN0Q29tbWVudHMuYmFubmVyICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBiYW5uZXIgPVxuICAgICAgICAgICAgICAvKiogQHR5cGUge0V4dHJhY3RDb21tZW50c09iamVjdH0gKi9cbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dHJhY3RDb21tZW50cy5iYW5uZXIgfHwgYEZvciBsaWNlbnNlIGluZm9ybWF0aW9uIHBsZWFzZSBzZWUgJHtwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZShuYW1lKSwgb3V0cHV0LmNvbW1lbnRzRmlsZW5hbWUpLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpfWA7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiYW5uZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGJhbm5lciA9IGJhbm5lcihvdXRwdXQuY29tbWVudHNGaWxlbmFtZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYmFubmVyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNvdXJjZSA9IG5ldyBDb25jYXRTb3VyY2Uoc2hlYmFuZyA/IGAke3NoZWJhbmd9XFxuYCA6IFwiXCIsIGAvKiEgJHtiYW5uZXJ9ICovXFxuYCwgb3V0cHV0LnNvdXJjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXh0cmFjdGVkQ29tbWVudHNTdHJpbmcgPSBvdXRwdXQuZXh0cmFjdGVkQ29tbWVudHMuc29ydCgpLmpvaW4oXCJcXG5cXG5cIik7XG4gICAgICAgICAgICBvdXRwdXQuZXh0cmFjdGVkQ29tbWVudHNTb3VyY2UgPSBuZXcgUmF3U291cmNlKGAke2V4dHJhY3RlZENvbW1lbnRzU3RyaW5nfVxcbmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IGNhY2hlSXRlbS5zdG9yZVByb21pc2Uoe1xuICAgICAgICAgICAgc291cmNlOiBvdXRwdXQuc291cmNlLFxuICAgICAgICAgICAgY29tbWVudHNGaWxlbmFtZTogb3V0cHV0LmNvbW1lbnRzRmlsZW5hbWUsXG4gICAgICAgICAgICBleHRyYWN0ZWRDb21tZW50c1NvdXJjZTogb3V0cHV0LmV4dHJhY3RlZENvbW1lbnRzU291cmNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuXG5cbiAgICAgICAgY29uc3QgbmV3SW5mbyA9IHtcbiAgICAgICAgICBtaW5pbWl6ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBleHRyYWN0ZWRDb21tZW50c1NvdXJjZVxuICAgICAgICB9ID0gb3V0cHV0OyAvLyBXcml0ZSBleHRyYWN0ZWQgY29tbWVudHMgdG8gY29tbWVudHNGaWxlbmFtZVxuXG4gICAgICAgIGlmIChleHRyYWN0ZWRDb21tZW50c1NvdXJjZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbW1lbnRzRmlsZW5hbWVcbiAgICAgICAgICB9ID0gb3V0cHV0O1xuICAgICAgICAgIG5ld0luZm8ucmVsYXRlZCA9IHtcbiAgICAgICAgICAgIGxpY2Vuc2U6IGNvbW1lbnRzRmlsZW5hbWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGFsbEV4dHJhY3RlZENvbW1lbnRzLnNldChuYW1lLCB7XG4gICAgICAgICAgICBleHRyYWN0ZWRDb21tZW50c1NvdXJjZSxcbiAgICAgICAgICAgIGNvbW1lbnRzRmlsZW5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBpbGF0aW9uLnVwZGF0ZUFzc2V0KG5hbWUsIHNvdXJjZSwgbmV3SW5mbyk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoc2NoZWR1bGVkVGFza3MpO1xuXG4gICAgaWYgKGluaXRpYWxpemVkV29ya2VyKSB7XG4gICAgICBhd2FpdCBpbml0aWFsaXplZFdvcmtlci5lbmQoKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlZGVmIHt7IHNvdXJjZTogaW1wb3J0KFwid2VicGFja1wiKS5zb3VyY2VzLlNvdXJjZSwgY29tbWVudHNGaWxlbmFtZTogc3RyaW5nLCBmcm9tOiBzdHJpbmcgfX0gRXh0cmFjdGVkQ29tbWVudHNJbmZvV0l0aEZyb20gKi9cblxuXG4gICAgYXdhaXQgQXJyYXkuZnJvbShhbGxFeHRyYWN0ZWRDb21tZW50cykuc29ydCgpLnJlZHVjZShcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1Byb21pc2U8dW5rbm93bj59IHByZXZpb3VzUHJvbWlzZVxuICAgICAqIEBwYXJhbSB7W3N0cmluZywgRXh0cmFjdGVkQ29tbWVudHNJbmZvXX0gZXh0cmFjdGVkQ29tbWVudHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeHRyYWN0ZWRDb21tZW50c0luZm9XSXRoRnJvbT59XG4gICAgICovXG4gICAgYXN5bmMgKHByZXZpb3VzUHJvbWlzZSwgW2Zyb20sIHZhbHVlXSkgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXMgPVxuICAgICAgLyoqIEB0eXBlIHtFeHRyYWN0ZWRDb21tZW50c0luZm9XSXRoRnJvbSB8IHVuZGVmaW5lZH0gKiovXG4gICAgICBhd2FpdCBwcmV2aW91c1Byb21pc2U7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbW1lbnRzRmlsZW5hbWUsXG4gICAgICAgIGV4dHJhY3RlZENvbW1lbnRzU291cmNlXG4gICAgICB9ID0gdmFsdWU7XG5cbiAgICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5jb21tZW50c0ZpbGVuYW1lID09PSBjb21tZW50c0ZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmcm9tOiBwcmV2aW91c0Zyb20sXG4gICAgICAgICAgc291cmNlOiBwcmV2U291cmNlXG4gICAgICAgIH0gPSBwcmV2aW91cztcbiAgICAgICAgY29uc3QgbWVyZ2VkTmFtZSA9IGAke3ByZXZpb3VzRnJvbX18JHtmcm9tfWA7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtjb21tZW50c0ZpbGVuYW1lfXwke21lcmdlZE5hbWV9YDtcbiAgICAgICAgY29uc3QgZVRhZyA9IFtwcmV2U291cmNlLCBleHRyYWN0ZWRDb21tZW50c1NvdXJjZV0ubWFwKGl0ZW0gPT4gY2FjaGUuZ2V0TGF6eUhhc2hlZEV0YWcoaXRlbSkpLnJlZHVjZSgocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSA9PiBjYWNoZS5tZXJnZUV0YWdzKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICBsZXQgc291cmNlID0gYXdhaXQgY2FjaGUuZ2V0UHJvbWlzZShuYW1lLCBlVGFnKTtcblxuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgIHNvdXJjZSA9IG5ldyBDb25jYXRTb3VyY2UoQXJyYXkuZnJvbShuZXcgU2V0KFsuLi5cbiAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ30qL1xuICAgICAgICAgIHByZXZTb3VyY2Uuc291cmNlKCkuc3BsaXQoXCJcXG5cXG5cIiksIC4uLlxuICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSovXG4gICAgICAgICAgZXh0cmFjdGVkQ29tbWVudHNTb3VyY2Uuc291cmNlKCkuc3BsaXQoXCJcXG5cXG5cIildKSkuam9pbihcIlxcblxcblwiKSk7XG4gICAgICAgICAgYXdhaXQgY2FjaGUuc3RvcmVQcm9taXNlKG5hbWUsIGVUYWcsIHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21waWxhdGlvbi51cGRhdGVBc3NldChjb21tZW50c0ZpbGVuYW1lLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBjb21tZW50c0ZpbGVuYW1lLFxuICAgICAgICAgIGZyb206IG1lcmdlZE5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhpc3RpbmdBc3NldCA9IGNvbXBpbGF0aW9uLmdldEFzc2V0KGNvbW1lbnRzRmlsZW5hbWUpO1xuXG4gICAgICBpZiAoZXhpc3RpbmdBc3NldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogZXhpc3RpbmdBc3NldC5zb3VyY2UsXG4gICAgICAgICAgY29tbWVudHNGaWxlbmFtZSxcbiAgICAgICAgICBmcm9tOiBjb21tZW50c0ZpbGVuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbXBpbGF0aW9uLmVtaXRBc3NldChjb21tZW50c0ZpbGVuYW1lLCBleHRyYWN0ZWRDb21tZW50c1NvdXJjZSwge1xuICAgICAgICBleHRyYWN0ZWRDb21tZW50czogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IGV4dHJhY3RlZENvbW1lbnRzU291cmNlLFxuICAgICAgICBjb21tZW50c0ZpbGVuYW1lLFxuICAgICAgICBmcm9tXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtQcm9taXNlPHVua25vd24+fSAqL1xuICAgIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHthbnl9IGVudmlyb25tZW50XG4gICAqIEByZXR1cm5zIHtUZXJzZXJFQ01BfVxuICAgKi9cblxuXG4gIHN0YXRpYyBnZXRFY21hVmVyc2lvbihlbnZpcm9ubWVudCkge1xuICAgIC8vIEVTIDZ0aFxuICAgIGlmIChlbnZpcm9ubWVudC5hcnJvd0Z1bmN0aW9uIHx8IGVudmlyb25tZW50LmNvbnN0IHx8IGVudmlyb25tZW50LmRlc3RydWN0dXJpbmcgfHwgZW52aXJvbm1lbnQuZm9yT2YgfHwgZW52aXJvbm1lbnQubW9kdWxlKSB7XG4gICAgICByZXR1cm4gMjAxNTtcbiAgICB9IC8vIEVTIDExdGhcblxuXG4gICAgaWYgKGVudmlyb25tZW50LmJpZ0ludExpdGVyYWwgfHwgZW52aXJvbm1lbnQuZHluYW1pY0ltcG9ydCkge1xuICAgICAgcmV0dXJuIDIwMjA7XG4gICAgfVxuXG4gICAgcmV0dXJuIDU7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29tcGlsZXJ9IGNvbXBpbGVyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuXG4gIGFwcGx5KGNvbXBpbGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3V0cHV0XG4gICAgfSA9IGNvbXBpbGVyLm9wdGlvbnM7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy50ZXJzZXJPcHRpb25zLmVjbWEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXJzZXJPcHRpb25zLmVjbWEgPSBUZXJzZXJQbHVnaW4uZ2V0RWNtYVZlcnNpb24ob3V0cHV0LmVudmlyb25tZW50IHx8IHt9KTtcbiAgICB9XG5cbiAgICBjb25zdCBwbHVnaW5OYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGNvbnN0IGF2YWlsYWJsZU51bWJlck9mQ29yZXMgPSBUZXJzZXJQbHVnaW4uZ2V0QXZhaWxhYmxlTnVtYmVyT2ZDb3Jlcyh0aGlzLm9wdGlvbnMucGFyYWxsZWwpO1xuICAgIGNvbXBpbGVyLmhvb2tzLmNvbXBpbGF0aW9uLnRhcChwbHVnaW5OYW1lLCBjb21waWxhdGlvbiA9PiB7XG4gICAgICBjb25zdCBob29rcyA9IGNvbXBpbGVyLndlYnBhY2suamF2YXNjcmlwdC5KYXZhc2NyaXB0TW9kdWxlc1BsdWdpbi5nZXRDb21waWxhdGlvbkhvb2tzKGNvbXBpbGF0aW9uKTtcbiAgICAgIGNvbnN0IGRhdGEgPSAoMCwgX3NlcmlhbGl6ZUphdmFzY3JpcHQuZGVmYXVsdCkoe1xuICAgICAgICB0ZXJzZXI6IHRlcnNlclBhY2thZ2VKc29uLnZlcnNpb24sXG4gICAgICAgIHRlcnNlck9wdGlvbnM6IHRoaXMub3B0aW9ucy50ZXJzZXJPcHRpb25zXG4gICAgICB9KTtcbiAgICAgIGhvb2tzLmNodW5rSGFzaC50YXAocGx1Z2luTmFtZSwgKGNodW5rLCBoYXNoKSA9PiB7XG4gICAgICAgIGhhc2gudXBkYXRlKFwiVGVyc2VyUGx1Z2luXCIpO1xuICAgICAgICBoYXNoLnVwZGF0ZShkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgY29tcGlsYXRpb24uaG9va3MucHJvY2Vzc0Fzc2V0cy50YXBQcm9taXNlKHtcbiAgICAgICAgbmFtZTogcGx1Z2luTmFtZSxcbiAgICAgICAgc3RhZ2U6IGNvbXBpbGVyLndlYnBhY2suQ29tcGlsYXRpb24uUFJPQ0VTU19BU1NFVFNfU1RBR0VfT1BUSU1JWkVfU0laRSxcbiAgICAgICAgYWRkaXRpb25hbEFzc2V0czogdHJ1ZVxuICAgICAgfSwgYXNzZXRzID0+IHRoaXMub3B0aW1pemUoY29tcGlsZXIsIGNvbXBpbGF0aW9uLCBhc3NldHMsIHtcbiAgICAgICAgYXZhaWxhYmxlTnVtYmVyT2ZDb3Jlc1xuICAgICAgfSkpO1xuICAgICAgY29tcGlsYXRpb24uaG9va3Muc3RhdHNQcmludGVyLnRhcChwbHVnaW5OYW1lLCBzdGF0cyA9PiB7XG4gICAgICAgIHN0YXRzLmhvb2tzLnByaW50LmZvcihcImFzc2V0LmluZm8ubWluaW1pemVkXCIpLnRhcChcInRlcnNlci13ZWJwYWNrLXBsdWdpblwiLCAobWluaW1pemVkLCB7XG4gICAgICAgICAgZ3JlZW4sXG4gICAgICAgICAgZm9ybWF0RmxhZ1xuICAgICAgICB9KSA9PiBtaW5pbWl6ZWQgP1xuICAgICAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuICAgICAgICBncmVlbihcbiAgICAgICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbiAgICAgICAgZm9ybWF0RmxhZyhcIm1pbmltaXplZFwiKSkgOiBcIlwiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblxudmFyIF9kZWZhdWx0ID0gVGVyc2VyUGx1Z2luO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/terser-webpack-plugin/dist/index.js\n");

/***/ }),

/***/ "./node_modules/terser-webpack-plugin/dist/minify.js":
/*!***********************************************************!*\
  !*** ./node_modules/terser-webpack-plugin/dist/minify.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __filename = \"/index.js\";\nvar __dirname = \"/\";\n/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst {\n  minify: terserMinify\n} = __webpack_require__(/*! terser */ \"./node_modules/terser/dist/bundle.min.js\");\n/** @typedef {import(\"source-map\").RawSourceMap} RawSourceMap */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n\n/** @typedef {import(\"./index.js\").CustomMinifyFunction} CustomMinifyFunction */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserMinifyOptions */\n\n/** @typedef {import(\"terser\").MinifyOutput} MinifyOutput */\n\n/** @typedef {import(\"terser\").FormatOptions} FormatOptions */\n\n/** @typedef {import(\"terser\").MangleOptions} MangleOptions */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n\n/**\n * @typedef {Object.<any, any>} CustomMinifyOptions\n */\n\n/**\n * @typedef {Object} InternalMinifyOptions\n * @property {string} name\n * @property {string} input\n * @property {RawSourceMap} [inputSourceMap]\n * @property {ExtractCommentsOptions} extractComments\n * @property {CustomMinifyFunction} [minify]\n * @property {TerserMinifyOptions | CustomMinifyOptions} minifyOptions\n */\n\n/**\n * @typedef {Array<string>} ExtractedComments\n */\n\n/**\n * @typedef {Promise<MinifyOutput & { extractedComments?: ExtractedComments}>} InternalMinifyResult\n */\n\n/**\n * @typedef {TerserMinifyOptions & { sourceMap: undefined } & ({ output: FormatOptions & { beautify: boolean } } | { format: FormatOptions & { beautify: boolean } })} NormalizedTerserMinifyOptions\n */\n\n/**\n * @param {TerserMinifyOptions} [terserOptions={}]\n * @returns {NormalizedTerserMinifyOptions}\n */\n\n\nfunction buildTerserOptions(terserOptions = {}) {\n  // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n  return { ...terserOptions,\n    compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress : { ...terserOptions.compress\n    },\n    // ecma: terserOptions.ecma,\n    // ie8: terserOptions.ie8,\n    // keep_classnames: terserOptions.keep_classnames,\n    // keep_fnames: terserOptions.keep_fnames,\n    mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : { ...terserOptions.mangle\n    },\n    // module: terserOptions.module,\n    // nameCache: { ...terserOptions.toplevel },\n    // the `output` option is deprecated\n    ...(terserOptions.format ? {\n      format: {\n        beautify: false,\n        ...terserOptions.format\n      }\n    } : {\n      output: {\n        beautify: false,\n        ...terserOptions.output\n      }\n    }),\n    parse: { ...terserOptions.parse\n    },\n    // safari10: terserOptions.safari10,\n    // Ignoring sourceMap from options\n    // eslint-disable-next-line no-undefined\n    sourceMap: undefined // toplevel: terserOptions.toplevel\n\n  };\n}\n/**\n * @param {any} value\n * @returns {boolean}\n */\n\n\nfunction isObject(value) {\n  const type = typeof value;\n  return value != null && (type === \"object\" || type === \"function\");\n}\n/**\n * @param {ExtractCommentsOptions} extractComments\n * @param {NormalizedTerserMinifyOptions} terserOptions\n * @param {ExtractedComments} extractedComments\n * @returns {ExtractCommentsFunction}\n */\n\n\nfunction buildComments(extractComments, terserOptions, extractedComments) {\n  /** @type {{ [index: string]: ExtractCommentsCondition }} */\n  const condition = {};\n  let comments;\n\n  if (terserOptions.format) {\n    ({\n      comments\n    } = terserOptions.format);\n  } else if (terserOptions.output) {\n    ({\n      comments\n    } = terserOptions.output);\n  }\n\n  condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n  if (typeof extractComments === \"boolean\" && extractComments) {\n    condition.extract = \"some\";\n  } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n    condition.extract = extractComments;\n  } else if (typeof extractComments === \"function\") {\n    condition.extract = extractComments;\n  } else if (extractComments && isObject(extractComments)) {\n    condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n  } else {\n    // No extract\n    // Preserve using \"commentsOpts\" or \"some\"\n    condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n    condition.extract = false;\n  } // Ensure that both conditions are functions\n\n\n  [\"preserve\", \"extract\"].forEach(key => {\n    /** @type {undefined | string} */\n    let regexStr;\n    /** @type {undefined | RegExp} */\n\n    let regex;\n\n    switch (typeof condition[key]) {\n      case \"boolean\":\n        condition[key] = condition[key] ? () => true : () => false;\n        break;\n\n      case \"function\":\n        break;\n\n      case \"string\":\n        if (condition[key] === \"all\") {\n          condition[key] = () => true;\n\n          break;\n        }\n\n        if (condition[key] === \"some\") {\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n\n          break;\n        }\n\n        regexStr =\n        /** @type {string} */\n        condition[key];\n\n        condition[key] =\n        /** @type {ExtractCommentsFunction} */\n        (astNode, comment) => new RegExp(\n        /** @type {string} */\n        regexStr).test(comment.value);\n\n        break;\n\n      default:\n        regex =\n        /** @type {RegExp} */\n        condition[key];\n\n        condition[key] =\n        /** @type {ExtractCommentsFunction} */\n        (astNode, comment) =>\n        /** @type {RegExp} */\n        regex.test(comment.value);\n\n    }\n  }); // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n\n  return (astNode, comment) => {\n    if (\n    /** @type {{ extract: ExtractCommentsFunction }} */\n    condition.extract(astNode, comment)) {\n      const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n      if (!extractedComments.includes(commentText)) {\n        extractedComments.push(commentText);\n      }\n    }\n\n    return (\n      /** @type {{ preserve: ExtractCommentsFunction }} */\n      condition.preserve(astNode, comment)\n    );\n  };\n}\n/**\n * @param {InternalMinifyOptions} options\n * @returns {InternalMinifyResult}\n */\n\n\nasync function minify(options) {\n  const {\n    name,\n    input,\n    inputSourceMap,\n    minify: minifyFn,\n    minifyOptions\n  } = options;\n\n  if (minifyFn) {\n    return minifyFn({\n      [name]: input\n    }, inputSourceMap, minifyOptions);\n  } // Copy terser options\n\n\n  const terserOptions = buildTerserOptions(minifyOptions); // Let terser generate a SourceMap\n\n  if (inputSourceMap) {\n    // @ts-ignore\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n  /** @type {ExtractedComments} */\n\n\n  const extractedComments = [];\n  const {\n    extractComments\n  } = options;\n\n  if (terserOptions.output) {\n    terserOptions.output.comments = buildComments(extractComments, terserOptions, extractedComments);\n  } else if (terserOptions.format) {\n    terserOptions.format.comments = buildComments(extractComments, terserOptions, extractedComments);\n  }\n\n  const result = await terserMinify({\n    [name]: input\n  }, terserOptions);\n  return { ...result,\n    extractedComments\n  };\n}\n/**\n * @param {string} options\n * @returns {InternalMinifyResult}\n */\n\n\nfunction transform(options) {\n  // 'use strict' => this === undefined (Clean Scope)\n  // Safer for possible security issues, albeit not critical at all here\n  // eslint-disable-next-line no-param-reassign\n  const evaluatedOptions =\n  /** @type {InternalMinifyOptions} */\n  // eslint-disable-next-line no-new-func\n  new Function(\"exports\", \"require\", \"module\", \"__filename\", \"__dirname\", `'use strict'\\nreturn ${options}`)(exports, __webpack_require__(\"./node_modules/terser-webpack-plugin/dist sync recursive\"), module, __filename, __dirname);\n  return minify(evaluatedOptions);\n}\n\nmodule.exports.minify = minify;\nmodule.exports.transform = transform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyLXdlYnBhY2stcGx1Z2luL2Rpc3QvbWluaWZ5LmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFhOztBQUViO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx3REFBUTtBQUNwQixjQUFjLG1DQUFtQzs7QUFFakQsY0FBYyw2Q0FBNkM7O0FBRTNELGNBQWMsMkNBQTJDOztBQUV6RCxjQUFjLGdDQUFnQzs7QUFFOUMsY0FBYywrQkFBK0I7O0FBRTdDLGNBQWMsZ0NBQWdDOztBQUU5QyxjQUFjLGdDQUFnQzs7QUFFOUMsY0FBYyw4Q0FBOEM7O0FBRTVELGNBQWMsK0NBQStDOztBQUU3RDtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsMkNBQTJDO0FBQ3pEOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0EsYUFBYSx5QkFBeUIsc0NBQXNDLEdBQUc7QUFDL0U7O0FBRUE7QUFDQSxhQUFhLHdCQUF3Qix1QkFBdUIsS0FBSywwQkFBMEIsc0JBQXNCLElBQUksMEJBQTBCLHFCQUFxQixHQUFHO0FBQ3ZLOztBQUVBO0FBQ0EsV0FBVyxxQkFBcUIsaUJBQWlCO0FBQ2pELGFBQWE7QUFDYjs7O0FBR0EsOENBQThDO0FBQzlDO0FBQ0EsV0FBVztBQUNYLHVGQUF1RjtBQUN2RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkgsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBLGVBQWUsNkNBQTZDO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0EsZUFBZSxvQkFBb0I7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQTtBQUNBLEdBQUcsR0FBRztBQUNOOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0EsNkRBQTZELGNBQWMsV0FBVyxjQUFjLEdBQUc7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7OztBQUdoQztBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBLGtHQUFrRyxRQUFRLFlBQVksK0VBQU8sVUFBVSxVQUFVLEVBQUUsU0FBUztBQUM1SjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQix3QkFBd0IsYSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tLWxldml0eS8uL25vZGVfbW9kdWxlcy90ZXJzZXItd2VicGFjay1wbHVnaW4vZGlzdC9taW5pZnkuanM/YTdiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3Qge1xuICBtaW5pZnk6IHRlcnNlck1pbmlmeVxufSA9IHJlcXVpcmUoXCJ0ZXJzZXJcIik7XG4vKiogQHR5cGVkZWYge2ltcG9ydChcInNvdXJjZS1tYXBcIikuUmF3U291cmNlTWFwfSBSYXdTb3VyY2VNYXAgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLkV4dHJhY3RDb21tZW50c09wdGlvbnN9IEV4dHJhY3RDb21tZW50c09wdGlvbnMgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLkN1c3RvbU1pbmlmeUZ1bmN0aW9ufSBDdXN0b21NaW5pZnlGdW5jdGlvbiAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcInRlcnNlclwiKS5NaW5pZnlPcHRpb25zfSBUZXJzZXJNaW5pZnlPcHRpb25zICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwidGVyc2VyXCIpLk1pbmlmeU91dHB1dH0gTWluaWZ5T3V0cHV0ICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwidGVyc2VyXCIpLkZvcm1hdE9wdGlvbnN9IEZvcm1hdE9wdGlvbnMgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCJ0ZXJzZXJcIikuTWFuZ2xlT3B0aW9uc30gTWFuZ2xlT3B0aW9ucyAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4vaW5kZXguanNcIikuRXh0cmFjdENvbW1lbnRzRnVuY3Rpb259IEV4dHJhY3RDb21tZW50c0Z1bmN0aW9uICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5FeHRyYWN0Q29tbWVudHNDb25kaXRpb259IEV4dHJhY3RDb21tZW50c0NvbmRpdGlvbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3QuPGFueSwgYW55Pn0gQ3VzdG9tTWluaWZ5T3B0aW9uc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSW50ZXJuYWxNaW5pZnlPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlucHV0XG4gKiBAcHJvcGVydHkge1Jhd1NvdXJjZU1hcH0gW2lucHV0U291cmNlTWFwXVxuICogQHByb3BlcnR5IHtFeHRyYWN0Q29tbWVudHNPcHRpb25zfSBleHRyYWN0Q29tbWVudHNcbiAqIEBwcm9wZXJ0eSB7Q3VzdG9tTWluaWZ5RnVuY3Rpb259IFttaW5pZnldXG4gKiBAcHJvcGVydHkge1RlcnNlck1pbmlmeU9wdGlvbnMgfCBDdXN0b21NaW5pZnlPcHRpb25zfSBtaW5pZnlPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXk8c3RyaW5nPn0gRXh0cmFjdGVkQ29tbWVudHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtQcm9taXNlPE1pbmlmeU91dHB1dCAmIHsgZXh0cmFjdGVkQ29tbWVudHM/OiBFeHRyYWN0ZWRDb21tZW50c30+fSBJbnRlcm5hbE1pbmlmeVJlc3VsdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1RlcnNlck1pbmlmeU9wdGlvbnMgJiB7IHNvdXJjZU1hcDogdW5kZWZpbmVkIH0gJiAoeyBvdXRwdXQ6IEZvcm1hdE9wdGlvbnMgJiB7IGJlYXV0aWZ5OiBib29sZWFuIH0gfSB8IHsgZm9ybWF0OiBGb3JtYXRPcHRpb25zICYgeyBiZWF1dGlmeTogYm9vbGVhbiB9IH0pfSBOb3JtYWxpemVkVGVyc2VyTWluaWZ5T3B0aW9uc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtUZXJzZXJNaW5pZnlPcHRpb25zfSBbdGVyc2VyT3B0aW9ucz17fV1cbiAqIEByZXR1cm5zIHtOb3JtYWxpemVkVGVyc2VyTWluaWZ5T3B0aW9uc31cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ1aWxkVGVyc2VyT3B0aW9ucyh0ZXJzZXJPcHRpb25zID0ge30pIHtcbiAgLy8gTmVlZCBkZWVwIGNvcHkgb2JqZWN0cyB0byBhdm9pZCBodHRwczovL2dpdGh1Yi5jb20vdGVyc2VyL3RlcnNlci9pc3N1ZXMvMzY2XG4gIHJldHVybiB7IC4uLnRlcnNlck9wdGlvbnMsXG4gICAgY29tcHJlc3M6IHR5cGVvZiB0ZXJzZXJPcHRpb25zLmNvbXByZXNzID09PSBcImJvb2xlYW5cIiA/IHRlcnNlck9wdGlvbnMuY29tcHJlc3MgOiB7IC4uLnRlcnNlck9wdGlvbnMuY29tcHJlc3NcbiAgICB9LFxuICAgIC8vIGVjbWE6IHRlcnNlck9wdGlvbnMuZWNtYSxcbiAgICAvLyBpZTg6IHRlcnNlck9wdGlvbnMuaWU4LFxuICAgIC8vIGtlZXBfY2xhc3NuYW1lczogdGVyc2VyT3B0aW9ucy5rZWVwX2NsYXNzbmFtZXMsXG4gICAgLy8ga2VlcF9mbmFtZXM6IHRlcnNlck9wdGlvbnMua2VlcF9mbmFtZXMsXG4gICAgbWFuZ2xlOiB0ZXJzZXJPcHRpb25zLm1hbmdsZSA9PSBudWxsID8gdHJ1ZSA6IHR5cGVvZiB0ZXJzZXJPcHRpb25zLm1hbmdsZSA9PT0gXCJib29sZWFuXCIgPyB0ZXJzZXJPcHRpb25zLm1hbmdsZSA6IHsgLi4udGVyc2VyT3B0aW9ucy5tYW5nbGVcbiAgICB9LFxuICAgIC8vIG1vZHVsZTogdGVyc2VyT3B0aW9ucy5tb2R1bGUsXG4gICAgLy8gbmFtZUNhY2hlOiB7IC4uLnRlcnNlck9wdGlvbnMudG9wbGV2ZWwgfSxcbiAgICAvLyB0aGUgYG91dHB1dGAgb3B0aW9uIGlzIGRlcHJlY2F0ZWRcbiAgICAuLi4odGVyc2VyT3B0aW9ucy5mb3JtYXQgPyB7XG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgYmVhdXRpZnk6IGZhbHNlLFxuICAgICAgICAuLi50ZXJzZXJPcHRpb25zLmZvcm1hdFxuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICBvdXRwdXQ6IHtcbiAgICAgICAgYmVhdXRpZnk6IGZhbHNlLFxuICAgICAgICAuLi50ZXJzZXJPcHRpb25zLm91dHB1dFxuICAgICAgfVxuICAgIH0pLFxuICAgIHBhcnNlOiB7IC4uLnRlcnNlck9wdGlvbnMucGFyc2VcbiAgICB9LFxuICAgIC8vIHNhZmFyaTEwOiB0ZXJzZXJPcHRpb25zLnNhZmFyaTEwLFxuICAgIC8vIElnbm9yaW5nIHNvdXJjZU1hcCBmcm9tIG9wdGlvbnNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgc291cmNlTWFwOiB1bmRlZmluZWQgLy8gdG9wbGV2ZWw6IHRlcnNlck9wdGlvbnMudG9wbGV2ZWxcblxuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT09IFwib2JqZWN0XCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbi8qKlxuICogQHBhcmFtIHtFeHRyYWN0Q29tbWVudHNPcHRpb25zfSBleHRyYWN0Q29tbWVudHNcbiAqIEBwYXJhbSB7Tm9ybWFsaXplZFRlcnNlck1pbmlmeU9wdGlvbnN9IHRlcnNlck9wdGlvbnNcbiAqIEBwYXJhbSB7RXh0cmFjdGVkQ29tbWVudHN9IGV4dHJhY3RlZENvbW1lbnRzXG4gKiBAcmV0dXJucyB7RXh0cmFjdENvbW1lbnRzRnVuY3Rpb259XG4gKi9cblxuXG5mdW5jdGlvbiBidWlsZENvbW1lbnRzKGV4dHJhY3RDb21tZW50cywgdGVyc2VyT3B0aW9ucywgZXh0cmFjdGVkQ29tbWVudHMpIHtcbiAgLyoqIEB0eXBlIHt7IFtpbmRleDogc3RyaW5nXTogRXh0cmFjdENvbW1lbnRzQ29uZGl0aW9uIH19ICovXG4gIGNvbnN0IGNvbmRpdGlvbiA9IHt9O1xuICBsZXQgY29tbWVudHM7XG5cbiAgaWYgKHRlcnNlck9wdGlvbnMuZm9ybWF0KSB7XG4gICAgKHtcbiAgICAgIGNvbW1lbnRzXG4gICAgfSA9IHRlcnNlck9wdGlvbnMuZm9ybWF0KTtcbiAgfSBlbHNlIGlmICh0ZXJzZXJPcHRpb25zLm91dHB1dCkge1xuICAgICh7XG4gICAgICBjb21tZW50c1xuICAgIH0gPSB0ZXJzZXJPcHRpb25zLm91dHB1dCk7XG4gIH1cblxuICBjb25kaXRpb24ucHJlc2VydmUgPSB0eXBlb2YgY29tbWVudHMgIT09IFwidW5kZWZpbmVkXCIgPyBjb21tZW50cyA6IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZXh0cmFjdENvbW1lbnRzID09PSBcImJvb2xlYW5cIiAmJiBleHRyYWN0Q29tbWVudHMpIHtcbiAgICBjb25kaXRpb24uZXh0cmFjdCA9IFwic29tZVwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHRyYWN0Q29tbWVudHMgPT09IFwic3RyaW5nXCIgfHwgZXh0cmFjdENvbW1lbnRzIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgY29uZGl0aW9uLmV4dHJhY3QgPSBleHRyYWN0Q29tbWVudHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4dHJhY3RDb21tZW50cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uZGl0aW9uLmV4dHJhY3QgPSBleHRyYWN0Q29tbWVudHM7XG4gIH0gZWxzZSBpZiAoZXh0cmFjdENvbW1lbnRzICYmIGlzT2JqZWN0KGV4dHJhY3RDb21tZW50cykpIHtcbiAgICBjb25kaXRpb24uZXh0cmFjdCA9IHR5cGVvZiBleHRyYWN0Q29tbWVudHMuY29uZGl0aW9uID09PSBcImJvb2xlYW5cIiAmJiBleHRyYWN0Q29tbWVudHMuY29uZGl0aW9uID8gXCJzb21lXCIgOiB0eXBlb2YgZXh0cmFjdENvbW1lbnRzLmNvbmRpdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiA/IGV4dHJhY3RDb21tZW50cy5jb25kaXRpb24gOiBcInNvbWVcIjtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBleHRyYWN0XG4gICAgLy8gUHJlc2VydmUgdXNpbmcgXCJjb21tZW50c09wdHNcIiBvciBcInNvbWVcIlxuICAgIGNvbmRpdGlvbi5wcmVzZXJ2ZSA9IHR5cGVvZiBjb21tZW50cyAhPT0gXCJ1bmRlZmluZWRcIiA/IGNvbW1lbnRzIDogXCJzb21lXCI7XG4gICAgY29uZGl0aW9uLmV4dHJhY3QgPSBmYWxzZTtcbiAgfSAvLyBFbnN1cmUgdGhhdCBib3RoIGNvbmRpdGlvbnMgYXJlIGZ1bmN0aW9uc1xuXG5cbiAgW1wicHJlc2VydmVcIiwgXCJleHRyYWN0XCJdLmZvckVhY2goa2V5ID0+IHtcbiAgICAvKiogQHR5cGUge3VuZGVmaW5lZCB8IHN0cmluZ30gKi9cbiAgICBsZXQgcmVnZXhTdHI7XG4gICAgLyoqIEB0eXBlIHt1bmRlZmluZWQgfCBSZWdFeHB9ICovXG5cbiAgICBsZXQgcmVnZXg7XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiBjb25kaXRpb25ba2V5XSkge1xuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY29uZGl0aW9uW2tleV0gPSBjb25kaXRpb25ba2V5XSA/ICgpID0+IHRydWUgOiAoKSA9PiBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBpZiAoY29uZGl0aW9uW2tleV0gPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICBjb25kaXRpb25ba2V5XSA9ICgpID0+IHRydWU7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25kaXRpb25ba2V5XSA9PT0gXCJzb21lXCIpIHtcbiAgICAgICAgICBjb25kaXRpb25ba2V5XSA9XG4gICAgICAgICAgLyoqIEB0eXBlIHtFeHRyYWN0Q29tbWVudHNGdW5jdGlvbn0gKi9cbiAgICAgICAgICAoYXN0Tm9kZSwgY29tbWVudCkgPT4gKGNvbW1lbnQudHlwZSA9PT0gXCJjb21tZW50MlwiIHx8IGNvbW1lbnQudHlwZSA9PT0gXCJjb21tZW50MVwiKSAmJiAvQHByZXNlcnZlfEBsaWN8QGNjX29ufF5cXCoqIS9pLnRlc3QoY29tbWVudC52YWx1ZSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2V4U3RyID1cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgIGNvbmRpdGlvbltrZXldO1xuXG4gICAgICAgIGNvbmRpdGlvbltrZXldID1cbiAgICAgICAgLyoqIEB0eXBlIHtFeHRyYWN0Q29tbWVudHNGdW5jdGlvbn0gKi9cbiAgICAgICAgKGFzdE5vZGUsIGNvbW1lbnQpID0+IG5ldyBSZWdFeHAoXG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICByZWdleFN0cikudGVzdChjb21tZW50LnZhbHVlKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVnZXggPVxuICAgICAgICAvKiogQHR5cGUge1JlZ0V4cH0gKi9cbiAgICAgICAgY29uZGl0aW9uW2tleV07XG5cbiAgICAgICAgY29uZGl0aW9uW2tleV0gPVxuICAgICAgICAvKiogQHR5cGUge0V4dHJhY3RDb21tZW50c0Z1bmN0aW9ufSAqL1xuICAgICAgICAoYXN0Tm9kZSwgY29tbWVudCkgPT5cbiAgICAgICAgLyoqIEB0eXBlIHtSZWdFeHB9ICovXG4gICAgICAgIHJlZ2V4LnRlc3QoY29tbWVudC52YWx1ZSk7XG5cbiAgICB9XG4gIH0pOyAvLyBSZWRlZmluZSB0aGUgY29tbWVudHMgZnVuY3Rpb24gdG8gZXh0cmFjdCBhbmQgcHJlc2VydmVcbiAgLy8gY29tbWVudHMgYWNjb3JkaW5nIHRvIHRoZSB0d28gY29uZGl0aW9uc1xuXG4gIHJldHVybiAoYXN0Tm9kZSwgY29tbWVudCkgPT4ge1xuICAgIGlmIChcbiAgICAvKiogQHR5cGUge3sgZXh0cmFjdDogRXh0cmFjdENvbW1lbnRzRnVuY3Rpb24gfX0gKi9cbiAgICBjb25kaXRpb24uZXh0cmFjdChhc3ROb2RlLCBjb21tZW50KSkge1xuICAgICAgY29uc3QgY29tbWVudFRleHQgPSBjb21tZW50LnR5cGUgPT09IFwiY29tbWVudDJcIiA/IGAvKiR7Y29tbWVudC52YWx1ZX0qL2AgOiBgLy8ke2NvbW1lbnQudmFsdWV9YDsgLy8gRG9uJ3QgaW5jbHVkZSBkdXBsaWNhdGUgY29tbWVudHNcblxuICAgICAgaWYgKCFleHRyYWN0ZWRDb21tZW50cy5pbmNsdWRlcyhjb21tZW50VGV4dCkpIHtcbiAgICAgICAgZXh0cmFjdGVkQ29tbWVudHMucHVzaChjb21tZW50VGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7eyBwcmVzZXJ2ZTogRXh0cmFjdENvbW1lbnRzRnVuY3Rpb24gfX0gKi9cbiAgICAgIGNvbmRpdGlvbi5wcmVzZXJ2ZShhc3ROb2RlLCBjb21tZW50KVxuICAgICk7XG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7SW50ZXJuYWxNaW5pZnlPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7SW50ZXJuYWxNaW5pZnlSZXN1bHR9XG4gKi9cblxuXG5hc3luYyBmdW5jdGlvbiBtaW5pZnkob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbmFtZSxcbiAgICBpbnB1dCxcbiAgICBpbnB1dFNvdXJjZU1hcCxcbiAgICBtaW5pZnk6IG1pbmlmeUZuLFxuICAgIG1pbmlmeU9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKG1pbmlmeUZuKSB7XG4gICAgcmV0dXJuIG1pbmlmeUZuKHtcbiAgICAgIFtuYW1lXTogaW5wdXRcbiAgICB9LCBpbnB1dFNvdXJjZU1hcCwgbWluaWZ5T3B0aW9ucyk7XG4gIH0gLy8gQ29weSB0ZXJzZXIgb3B0aW9uc1xuXG5cbiAgY29uc3QgdGVyc2VyT3B0aW9ucyA9IGJ1aWxkVGVyc2VyT3B0aW9ucyhtaW5pZnlPcHRpb25zKTsgLy8gTGV0IHRlcnNlciBnZW5lcmF0ZSBhIFNvdXJjZU1hcFxuXG4gIGlmIChpbnB1dFNvdXJjZU1hcCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0ZXJzZXJPcHRpb25zLnNvdXJjZU1hcCA9IHtcbiAgICAgIGFzT2JqZWN0OiB0cnVlXG4gICAgfTtcbiAgfVxuICAvKiogQHR5cGUge0V4dHJhY3RlZENvbW1lbnRzfSAqL1xuXG5cbiAgY29uc3QgZXh0cmFjdGVkQ29tbWVudHMgPSBbXTtcbiAgY29uc3Qge1xuICAgIGV4dHJhY3RDb21tZW50c1xuICB9ID0gb3B0aW9ucztcblxuICBpZiAodGVyc2VyT3B0aW9ucy5vdXRwdXQpIHtcbiAgICB0ZXJzZXJPcHRpb25zLm91dHB1dC5jb21tZW50cyA9IGJ1aWxkQ29tbWVudHMoZXh0cmFjdENvbW1lbnRzLCB0ZXJzZXJPcHRpb25zLCBleHRyYWN0ZWRDb21tZW50cyk7XG4gIH0gZWxzZSBpZiAodGVyc2VyT3B0aW9ucy5mb3JtYXQpIHtcbiAgICB0ZXJzZXJPcHRpb25zLmZvcm1hdC5jb21tZW50cyA9IGJ1aWxkQ29tbWVudHMoZXh0cmFjdENvbW1lbnRzLCB0ZXJzZXJPcHRpb25zLCBleHRyYWN0ZWRDb21tZW50cyk7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXJzZXJNaW5pZnkoe1xuICAgIFtuYW1lXTogaW5wdXRcbiAgfSwgdGVyc2VyT3B0aW9ucyk7XG4gIHJldHVybiB7IC4uLnJlc3VsdCxcbiAgICBleHRyYWN0ZWRDb21tZW50c1xuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uc1xuICogQHJldHVybnMge0ludGVybmFsTWluaWZ5UmVzdWx0fVxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgLy8gJ3VzZSBzdHJpY3QnID0+IHRoaXMgPT09IHVuZGVmaW5lZCAoQ2xlYW4gU2NvcGUpXG4gIC8vIFNhZmVyIGZvciBwb3NzaWJsZSBzZWN1cml0eSBpc3N1ZXMsIGFsYmVpdCBub3QgY3JpdGljYWwgYXQgYWxsIGhlcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbnN0IGV2YWx1YXRlZE9wdGlvbnMgPVxuICAvKiogQHR5cGUge0ludGVybmFsTWluaWZ5T3B0aW9uc30gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIG5ldyBGdW5jdGlvbihcImV4cG9ydHNcIiwgXCJyZXF1aXJlXCIsIFwibW9kdWxlXCIsIFwiX19maWxlbmFtZVwiLCBcIl9fZGlybmFtZVwiLCBgJ3VzZSBzdHJpY3QnXFxucmV0dXJuICR7b3B0aW9uc31gKShleHBvcnRzLCByZXF1aXJlLCBtb2R1bGUsIF9fZmlsZW5hbWUsIF9fZGlybmFtZSk7XG4gIHJldHVybiBtaW5pZnkoZXZhbHVhdGVkT3B0aW9ucyk7XG59XG5cbm1vZHVsZS5leHBvcnRzLm1pbmlmeSA9IG1pbmlmeTtcbm1vZHVsZS5leHBvcnRzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser-webpack-plugin/dist/minify.js\n");

/***/ }),

/***/ "./node_modules/terser-webpack-plugin/dist/options.json":
/*!**************************************************************!*\
  !*** ./node_modules/terser-webpack-plugin/dist/options.json ***!
  \**************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"definitions":{"Rule":{"description":"Filtering rule as regex or string.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"Rules":{"description":"Filtering rules.","anyOf":[{"type":"array","items":{"description":"A rule condition.","oneOf":[{"$ref":"#/definitions/Rule"}]}},{"$ref":"#/definitions/Rule"}]}},"title":"TerserPluginOptions","type":"object","additionalProperties":false,"properties":{"test":{"description":"Include all modules that pass test assertion.","oneOf":[{"$ref":"#/definitions/Rules"}]},"include":{"description":"Include all modules matching any of these conditions.","oneOf":[{"$ref":"#/definitions/Rules"}]},"exclude":{"description":"Exclude all modules matching any of these conditions.","oneOf":[{"$ref":"#/definitions/Rules"}]},"terserOptions":{"description":"Options for `terser`.","additionalProperties":true,"type":"object"},"extractComments":{"description":"Whether comments shall be extracted to a separate file.","anyOf":[{"type":"boolean"},{"type":"string","minLength":1},{"instanceof":"RegExp"},{"instanceof":"Function"},{"additionalProperties":false,"properties":{"condition":{"anyOf":[{"type":"boolean"},{"type":"string","minLength":1},{"instanceof":"RegExp"},{"instanceof":"Function"}]},"filename":{"anyOf":[{"type":"string","minLength":1},{"instanceof":"Function"}]},"banner":{"anyOf":[{"type":"boolean"},{"type":"string","minLength":1},{"instanceof":"Function"}]}},"type":"object"}]},"parallel":{"description":"Use multi-process parallel running to improve the build speed.","anyOf":[{"type":"boolean"},{"type":"integer"}]},"minify":{"description":"Allows you to override default minify function.","instanceof":"Function"}}}');

/***/ })

}]);